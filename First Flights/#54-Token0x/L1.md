# Unnecessary Zero Memory Stores in Assembly Functions

Severity: Low (Gas Optimization) âš¡

## Description

The contract contains several assembly blocks that unnecessarily store zero values (0x00) to memory locations before reverting or returning. These operations consume extra gas without providing any functional benefit. Memory slots are already initialized to zero by default in the EVM, making these explicit zero stores redundant.

The issue is particularly evident in error handling paths and return statements where memory is unnecessarily zeroed before reverting or returning data.

```solidity
// This is one of the function where we store 0 data in memory which can be deleted
function _balanceOf(address owner) internal view returns (uint256) {
        assembly {
            if iszero(owner) {
                revert(0, 0)
            }

            let baseSlot := _balances.slot
            let ptr := mload(0x40)
            mstore(ptr, owner)
            mstore(add(ptr, 0x20), baseSlot)
            let dataSlot := keccak256(ptr, 0x40)
            let amount := sload(dataSlot)
            mstore(ptr, amount)
            mstore(add(ptr, 0x20), 0) //<@ we can remove this line. mstore with 0 data
            return(ptr, 0x20)
        }
    }
```

## Risk

**Likelihood**:HIGH

* The code is always present in the contract

**Impact**:LOW

* Gas inefficiency: Unnecessary gas costs for users
* Code bloat: Additional operations that serve no purpose
* Minor performance impact: Extra EVM operations slow down execution

## Proof of Concept

Run the current test suite Token.t.sol with `forge test` in terminal. We can get each function gas list
* \[PASS] test\_allowance() (gas: 91933)

  \[PASS] test\_approveRevert() (gas: 12744)

  \[PASS] test\_burn() (gas: 47459)

  \[PASS] test\_burnRevert() (gas: 9900)

  \[PASS] test\_metadata() (gas: 20271)

  \[PASS] test\_mint() (gas: 58836)

  \[PASS] test\_mintRevert() (gas: 9836)

  \[PASS] test\_spendallowanceRevert() (gas: 93551)

  \[PASS] test\_transfer() (gas: 93646)

  \[PASS] test\_transferFrom() (gas: 104014)

  \[PASS] test\_transferRevert() (gas: 62946)

  \[PASS] test\_transferRevert2() (gas: 65918)

If we remove all line with mstore(location, 0x00) and we run the same test suite

* \[PASS] test\_allowance() (gas: 91919)

  \[PASS] test\_approveRevert() (gas: 12730)

  \[PASS] test\_burn() (gas: 47436)

  \[PASS] test\_burnRevert() (gas: 9887)

  \[PASS] test\_metadata() (gas: 20271)

  \[PASS] test\_mint() (gas: 58822)

  \[PASS] test\_mintRevert() (gas: 9823)

  \[PASS] test\_spendallowanceRevert() (gas: 93551)

  \[PASS] test\_transfer() (gas: 93604)

  \[PASS] test\_transferFrom() (gas: 103986)

  \[PASS] test\_transferRevert() (gas: 62919)

  \[PASS] test\_transferRevert2() (gas: 65904)

## Recommended Mitigation
Remove all unnecessary codes inside contract :

<details />

```diff
contract ERC20Internals {
    mapping(address account => uint256) internal _balances;
    mapping(address account => mapping(address spender => uint256)) internal _allowances;

    uint256 internal _totalSupply;

    string internal _name;
    string internal _symbol;

    function totalSupply_() internal view returns (uint256) {
        assembly {
            let slot := _totalSupply.slot
            let supply := sload(slot)
            mstore(0x00, supply)
            return(0x00, 0x20)
        }
    }

    function _balanceOf(address owner) internal view returns (uint256) {
        assembly {
            if iszero(owner) {
                revert(0, 0)
            }

            let baseSlot := _balances.slot
            let ptr := mload(0x40)
            mstore(ptr, owner)
            mstore(add(ptr, 0x20), baseSlot)
            let dataSlot := keccak256(ptr, 0x40)
            let amount := sload(dataSlot)
            mstore(ptr, amount)
-            mstore(add(ptr, 0x20), 0) 
            return(ptr, 0x20)
        }
    }

    function _approve(address owner, address spender, uint256 value) internal virtual returns (bool success) {
        assembly ("memory-safe") {
            if iszero(owner) {
                //0xe602df05 ERC20InvalidApprover(address)
                mstore(0x00, shl(224, 0xe602df05))
-                mstore(add(0x00, 4), owner)
                revert(0x00, 0x24)
            }
            if iszero(spender) {
                //0x94280d62 ERC20InvalidSpender(address)
                mstore(0x00, shl(224, 0x94280d62))
-                mstore(add(0x00, 4), spender)
                revert(0x00, 0x24)
            }

            let ptr := mload(0x40)
            let baseSlot := _allowances.slot

            mstore(ptr, owner)
            mstore(add(ptr, 0x20), baseSlot)
            let initialHash := keccak256(ptr, 0x40)
            mstore(ptr, spender)
            mstore(add(ptr, 0x20), initialHash)

            let allowanceSlot := keccak256(ptr, 0x40)
            sstore(allowanceSlot, value)

            success := 1

            mstore(0x00, value)
            log3(0x00, 0x20, 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925, owner, spender)
        }
    }

    function _allowance(address owner, address spender) internal view returns (uint256 remaining) {
        assembly {
            if or(iszero(owner), iszero(spender)) {
                revert(0, 0)
            }

            let ptr := mload(0x40)
            let baseSlot := _allowances.slot

            mstore(ptr, owner)
            mstore(add(ptr, 0x20), baseSlot)
            let initialHash := keccak256(ptr, 0x40)
            mstore(ptr, spender)
            mstore(add(ptr, 0x20), initialHash)

            let allowanceSlot := keccak256(ptr, 0x40)
            remaining := sload(allowanceSlot)
        }
    }

    function _transfer(address from, address to, uint256 value) internal returns (bool success) {
        assembly ("memory-safe") {
            if iszero(from) {
                //ERC20InvalidSender(address) 0x96c6fd1e
                mstore(0x00, shl(224, 0x96c6fd1e))
-                mstore(add(0x00, 4), 0x00)
                revert(0x00, 0x24)
            }

            if iszero(to) {
                //0xec442f05 ERC20InvalidReceiver(address)
                mstore(0x00, shl(224, 0xec442f05))
-                mstore(add(0x00, 4), 0x00)
                revert(0x00, 0x24)
            }

            let ptr := mload(0x40)
            let baseSlot := _balances.slot

            mstore(ptr, from)
            mstore(add(ptr, 0x20), baseSlot)
            let fromSlot := keccak256(ptr, 0x40)
            let fromAmount := sload(fromSlot)
            mstore(ptr, to)
            mstore(add(ptr, 0x20), baseSlot)
            let toSlot := keccak256(ptr, 0x40)
            let toAmount := sload(toSlot)

            if lt(fromAmount, value) {
                //0xe450d38c ERC20InsufficientBalance(address,uint256,uint256)
                mstore(0x00, shl(224, 0xe450d38c))
                mstore(add(0x00, 4), from)
                mstore(add(0x00, 0x24), fromAmount)
                mstore(add(0x00, 0x44), value)
                revert(0x00, 0x64)
            }

            sstore(fromSlot, sub(fromAmount, value))
            sstore(toSlot, add(toAmount, value))
            success := 1
            mstore(ptr, value)
            log3(ptr, 0x20, 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, from, to)
        }
    }

    function _mint(address account, uint256 value) internal {
        assembly ("memory-safe") {
            if iszero(account) {
                //0xec442f05 ERC20InvalidReceiver(address)
                mstore(0x00, shl(224, 0xec442f05))
-                mstore(add(0x00, 4), 0x00)
                revert(0x00, 0x24)
            }

            let ptr := mload(0x40)
            let balanceSlot := _balances.slot
            let supplySlot := _totalSupply.slot

            let supply := sload(supplySlot)
            sstore(supplySlot, add(supply, value))

            mstore(ptr, account)
            mstore(add(ptr, 0x20), balanceSlot)

            let accountBalanceSlot := keccak256(ptr, 0x40)
            let accountBalance := sload(accountBalanceSlot)
            sstore(accountBalanceSlot, add(accountBalance, value))
        }
    }

    function _burn(address account, uint256 value) internal {
        assembly ("memory-safe") {
            if iszero(account) {
                //ERC20InvalidSender(address) 0x96c6fd1e
                mstore(0x00, shl(224, 0x96c6fd1e))
-                mstore(add(0x00, 4), 0x00)
                revert(0x00, 0x24)
            }

            let ptr := mload(0x40)
            let balanceSlot := _balances.slot
            let supplySlot := _totalSupply.slot

            let supply := sload(supplySlot)
            sstore(supplySlot, sub(supply, value))

            mstore(ptr, account)
            mstore(add(ptr, 0x20), balanceSlot)

            let accountBalanceSlot := keccak256(ptr, 0x40)
            let accountBalance := sload(accountBalanceSlot)
            sstore(accountBalanceSlot, sub(accountBalance, value))
        }
    }

    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
        assembly ("memory-safe") {
            let ptr := mload(0x40)
            let baseSlot := _allowances.slot
            mstore(ptr, owner)
            mstore(add(ptr, 0x20), baseSlot)
            let initialHash := keccak256(ptr, 0x40)
            mstore(ptr, spender)
            mstore(add(ptr, 0x20), initialHash)
            let allowanceSlot := keccak256(ptr, 0x40)
            let currentAllowance := sload(allowanceSlot)

            if lt(currentAllowance, value) {
                //ERC20InsufficientAllowance(address,uint256,uint256)	0xfb8f41b2
                mstore(0x00, shl(224, 0xfb8f41b2))
                mstore(add(0x00, 4), spender)
                mstore(add(0x00, 0x24), currentAllowance)
                mstore(add(0x00, 0x44), value)
                revert(0, 0x64)
            }
            sstore(allowanceSlot, sub(currentAllowance, value))
        }
    }
}
```
