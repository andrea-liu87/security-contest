# Unchecked User Input in Adjust Function Leading to Arithmetic Overflow/Underflow

## Summary
The `adjust()` function within `Lender.sol` allows users to withdraw deposited collateral. However, the function fails to validate user input against their actual balance. If a user submits a withdrawal amount exceeding their available balance, the transaction will revert due to an arithmetic underflow/overflow error, resulting in unnecessary gas consumption for the user.

## Root Cause
Missing user input check on `Lender.sol::adjust()` line 274
```Solidity
function adjust(address account, int collateralDelta, int debtDelta) public {
    // ... other code before

    // Withdraw collateral (stored in internal representation)
 @> _cachedCollateralBalances[account] -= internalAmount; 
    //internalAmount should be checked not greater than _cachedCollateralBalances[account]
    
    // Transfer actual token amount (rounded down)
    collateral.safeTransfer(msg.sender, collateralAmount);

    // ... other code after
```

## Impact
- Users attempting to withdraw amounts exceeding their balance will experience failed transactions, leading to confusion and frustration. The error message from the arithmetic overflow is generic (panic code 0x11), providing no clear feedback about the actual issue (insufficient balance).
- Users pay for the entire transaction gas cost even when the transaction reverts, directly impacting their funds.

## PoC
Inside existing test suite Lender.t.sol add bellow test function
```Solidity
    function test_withdraw_exceedBalance() public {
        // Setup: create a scenario where user try to withdraw deposit that exceed its balance
        uint collateralAmount = 500e18;
        int redeemAmount = 510e18;
        
        // Prepare test data
        address userA = address(0xBEEF);
        address userB = makeAddr("userB");
        ERC20Mock collateral = ERC20Mock(address(lender.collateral()));
        
        // Setup: mint collateral to each user
        collateral.mint(userA, collateralAmount);
        collateral.mint(userB, collateralAmount);

        vm.startPrank(userB);
        collateral.approve(address(lender), collateralAmount);
        lender.adjust(userB, int256(collateralAmount), 0, false); // opt into non redeemable
        
        uint startingBalance = collateral.balanceOf(address(lender));
        assertEq(startingBalance, collateralAmount); 
        vm.stopPrank();
        
        // Setup: userA deposit
        vm.startPrank(userA);
        collateral.approve(address(lender), collateralAmount);
        lender.adjust(userA, int256(collateralAmount), 0, false); // opt into non redeemable
        
        uint balance2 = collateral.balanceOf(address(lender));
        assertEq(balance2, 2 * collateralAmount);

        // withdraw exceed deposit amount
        vm.expectRevert();
        lender.adjust(userA, -type(int256).max, 0, false);
        
        vm.stopPrank();
    }
```

## Mitigation
Add input check before the operation
```diff
function adjust(address account, int collateralDelta, int debtDelta) public {
    // ... other code before

    // Withdraw collateral (stored in internal representation)
    uint userBalance = _cachedCollateralBalances[account];
    if (internalAmount >= userBalance) {
        _cachedCollateralBalances[account] -= userBalance;
    } else {
    _cachedCollateralBalances[account] -= internalAmount; 
    }
    //internalAmount should be checked not greater than _cachedCollateralBalances[account]
    
    // Transfer actual token amount (rounded down)
    collateral.safeTransfer(msg.sender, collateralAmount);

    // ... other code after
```


